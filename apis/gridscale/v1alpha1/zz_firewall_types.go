// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type FirewallInitParameters struct {

	// List of labels in the format [ "label1", "label2" ].
	// List of labels.
	// +listType=set
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv4 addresses.
	RulesV4In []RulesV4InInitParameters `json:"rulesV4In,omitempty" tf:"rules_v4_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv4 addresses.
	RulesV4Out []RulesV4OutInitParameters `json:"rulesV4Out,omitempty" tf:"rules_v4_out,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv6 addresses.
	RulesV6In []RulesV6InInitParameters `json:"rulesV6In,omitempty" tf:"rules_v6_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv6 addresses.
	RulesV6Out []RulesV6OutInitParameters `json:"rulesV6Out,omitempty" tf:"rules_v6_out,omitempty"`
}

type FirewallObservation struct {

	// The date and time of the last object change.
	// The date and time of the last object change.
	ChangeTime *string `json:"changeTime,omitempty" tf:"change_time,omitempty"`

	// The date and time the object was initially created.
	// The date and time the object was initially created.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// Description of the firewall.
	// Description of the Firewall.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The UUID of the firewall.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// List of labels in the format [ "label1", "label2" ].
	// List of labels.
	// +listType=set
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The human-readable name of the location. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the location. It supports the full UTF-8 character set, with a maximum of 64 characters
	LocationName *string `json:"locationName,omitempty" tf:"location_name,omitempty"`

	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The information about networks which are related to this firewall.
	Network []NetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// The object is private, the value will be true. Otherwise the value will be false.
	// The object is private, the value will be true. Otherwise the value will be false.
	Private *bool `json:"private,omitempty" tf:"private,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv4 addresses.
	RulesV4In []RulesV4InObservation `json:"rulesV4In,omitempty" tf:"rules_v4_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv4 addresses.
	RulesV4Out []RulesV4OutObservation `json:"rulesV4Out,omitempty" tf:"rules_v4_out,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv6 addresses.
	RulesV6In []RulesV6InObservation `json:"rulesV6In,omitempty" tf:"rules_v6_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv6 addresses.
	RulesV6Out []RulesV6OutObservation `json:"rulesV6Out,omitempty" tf:"rules_v6_out,omitempty"`

	// Status indicates the status of the object.
	// Status indicates the status of the object
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type FirewallParameters struct {

	// List of labels in the format [ "label1", "label2" ].
	// List of labels.
	// +kubebuilder:validation:Optional
	// +listType=set
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv4 addresses.
	// +kubebuilder:validation:Optional
	RulesV4In []RulesV4InParameters `json:"rulesV4In,omitempty" tf:"rules_v4_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv4 addresses.
	// +kubebuilder:validation:Optional
	RulesV4Out []RulesV4OutParameters `json:"rulesV4Out,omitempty" tf:"rules_v4_out,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv6 addresses.
	// +kubebuilder:validation:Optional
	RulesV6In []RulesV6InParameters `json:"rulesV6In,omitempty" tf:"rules_v6_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv6 addresses.
	// +kubebuilder:validation:Optional
	RulesV6Out []RulesV6OutParameters `json:"rulesV6Out,omitempty" tf:"rules_v6_out,omitempty"`
}

type NetworkInitParameters struct {
}

type NetworkObservation struct {

	// The date and time the object was initially created.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// Name of the network.
	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`

	// The object UUID or id of the network.
	NetworkUUID *string `json:"networkUuid,omitempty" tf:"network_uuid,omitempty"`

	// Name of the firewall.
	ObjectName *string `json:"objectName,omitempty" tf:"object_name,omitempty"`

	// The object UUID or id of the firewall.
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`
}

type NetworkParameters struct {
}

type RulesV4InInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV4InObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV4InParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV4OutInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV4OutObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV4OutParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV6InInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV6InObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV6InParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV6OutInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV6OutObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type RulesV6OutParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

// FirewallSpec defines the desired state of Firewall
type FirewallSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FirewallParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider FirewallInitParameters `json:"initProvider,omitempty"`
}

// FirewallStatus defines the observed state of Firewall.
type FirewallStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FirewallObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Firewall is the Schema for the Firewalls API. Manages a firewall in gridscale.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gridscale}
type Firewall struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   FirewallSpec   `json:"spec"`
	Status FirewallStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FirewallList contains a list of Firewalls
type FirewallList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Firewall `json:"items"`
}

// Repository type metadata.
var (
	Firewall_Kind             = "Firewall"
	Firewall_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Firewall_Kind}.String()
	Firewall_KindAPIVersion   = Firewall_Kind + "." + CRDGroupVersion.String()
	Firewall_GroupVersionKind = CRDGroupVersion.WithKind(Firewall_Kind)
)

func init() {
	SchemeBuilder.Register(&Firewall{}, &FirewallList{})
}
