// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type HardwareProfileConfigInitParameters struct {

	// Boolean.
	HypervExtensions *bool `json:"hypervExtensions,omitempty" tf:"hyperv_extensions,omitempty"`

	// Allowed values: "i440fx", "q35_bios", "q35_uefi".
	Machinetype *string `json:"machinetype,omitempty" tf:"machinetype,omitempty"`

	// Boolean.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty" tf:"nested_virtualization,omitempty"`

	// Allowed values: "e1000", "e1000e", "virtio", "vmxnet3".
	NetworkModel *string `json:"networkModel,omitempty" tf:"network_model,omitempty"`

	// Boolean.
	SerialInterface *bool `json:"serialInterface,omitempty" tf:"serial_interface,omitempty"`

	// Boolean.
	ServerRenice *bool `json:"serverRenice,omitempty" tf:"server_renice,omitempty"`

	// Allowed values: "ide", "sata", "virtio_scsi", "virtio_block".
	StorageDevice *string `json:"storageDevice,omitempty" tf:"storage_device,omitempty"`

	// Allowed values: "nec_xhci", "piix3_uhci".
	UsbController *string `json:"usbController,omitempty" tf:"usb_controller,omitempty"`
}

type HardwareProfileConfigObservation struct {

	// Boolean.
	HypervExtensions *bool `json:"hypervExtensions,omitempty" tf:"hyperv_extensions,omitempty"`

	// Allowed values: "i440fx", "q35_bios", "q35_uefi".
	Machinetype *string `json:"machinetype,omitempty" tf:"machinetype,omitempty"`

	// Boolean.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty" tf:"nested_virtualization,omitempty"`

	// Allowed values: "e1000", "e1000e", "virtio", "vmxnet3".
	NetworkModel *string `json:"networkModel,omitempty" tf:"network_model,omitempty"`

	// Boolean.
	SerialInterface *bool `json:"serialInterface,omitempty" tf:"serial_interface,omitempty"`

	// Boolean.
	ServerRenice *bool `json:"serverRenice,omitempty" tf:"server_renice,omitempty"`

	// Allowed values: "ide", "sata", "virtio_scsi", "virtio_block".
	StorageDevice *string `json:"storageDevice,omitempty" tf:"storage_device,omitempty"`

	// Allowed values: "nec_xhci", "piix3_uhci".
	UsbController *string `json:"usbController,omitempty" tf:"usb_controller,omitempty"`
}

type HardwareProfileConfigParameters struct {

	// Boolean.
	// +kubebuilder:validation:Optional
	HypervExtensions *bool `json:"hypervExtensions,omitempty" tf:"hyperv_extensions,omitempty"`

	// Allowed values: "i440fx", "q35_bios", "q35_uefi".
	// +kubebuilder:validation:Optional
	Machinetype *string `json:"machinetype,omitempty" tf:"machinetype,omitempty"`

	// Boolean.
	// +kubebuilder:validation:Optional
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty" tf:"nested_virtualization,omitempty"`

	// Allowed values: "e1000", "e1000e", "virtio", "vmxnet3".
	// +kubebuilder:validation:Optional
	NetworkModel *string `json:"networkModel,omitempty" tf:"network_model,omitempty"`

	// Boolean.
	// +kubebuilder:validation:Optional
	SerialInterface *bool `json:"serialInterface,omitempty" tf:"serial_interface,omitempty"`

	// Boolean.
	// +kubebuilder:validation:Optional
	ServerRenice *bool `json:"serverRenice,omitempty" tf:"server_renice,omitempty"`

	// Allowed values: "ide", "sata", "virtio_scsi", "virtio_block".
	// +kubebuilder:validation:Optional
	StorageDevice *string `json:"storageDevice,omitempty" tf:"storage_device,omitempty"`

	// Allowed values: "nec_xhci", "piix3_uhci".
	// +kubebuilder:validation:Optional
	UsbController *string `json:"usbController,omitempty" tf:"usb_controller,omitempty"`
}

type NetworkRulesV4InInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV4InObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV4InParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV4OutInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV4OutObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV4OutParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV6InInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV6InObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV6InParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV6OutInitParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV6OutObservation struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Comment.
	// Comment.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type NetworkRulesV6OutParameters struct {

	// This defines what the firewall will do. Either accept or drop.
	// This defines what the firewall will do. Either accept or drop.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// Comment.
	// Comment.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
	// +kubebuilder:validation:Optional
	DstCidr *string `json:"dstCidr,omitempty" tf:"dst_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	DstPort *string `json:"dstPort,omitempty" tf:"dst_port,omitempty"`

	// The order at which the firewall will compare packets against its rules. A packet will be compared against the first rule, it will either allow it to pass or block it and it won't be matched against any other rules. However, if it does no match the rule, then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// The order at which the firewall will compare packets against its rules.
	// A packet will be compared against the first rule, it will either allow it to pass or block it
	// and it won't be matched against any other rules. However, if it does no match the rule,
	// then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order" tf:"order,omitempty"`

	// Either 'udp' or 'tcp'.
	// Either 'udp' or 'tcp'
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
	// +kubebuilder:validation:Optional
	SrcCidr *string `json:"srcCidr,omitempty" tf:"src_cidr,omitempty"`

	// A Number between 1 and 65535, port ranges are separated by a colon for FTP.
	// A Number between 1 and 65535, port ranges are seperated by a colon for FTP
	// +kubebuilder:validation:Optional
	SrcPort *string `json:"srcPort,omitempty" tf:"src_port,omitempty"`
}

type ServerInitParameters struct {

	// If the server should be auto-started in case of a failure (default=true).
	// If the server should be auto-started in case of a failure (default=true).
	AutoRecovery *bool `json:"autoRecovery,omitempty" tf:"auto_recovery,omitempty"`

	// Defines which Availability-Zone the Server is placed.
	// Defines which Availability-Zone the Server is placed.
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// The number of server cores.
	// The number of server cores.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// The hardware profile of the Server. Options are default, legacy, nested, cisco_csr, sophos_utm, f5_bigip and q35 at the moment of writing. If it is not set, the backend will set it by default. Check the official docs.
	// Specifies the hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time.
	HardwareProfile *string `json:"hardwareProfile,omitempty" tf:"hardware_profile,omitempty"`

	// Specifies the custom hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time. Note: If hardware_profile_config is set, all fields of hardware_profile_config MUST be set.
	// Specifies the custom hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time.
	HardwareProfileConfig []HardwareProfileConfigInitParameters `json:"hardwareProfileConfig,omitempty" tf:"hardware_profile_config,omitempty"`

	// The UUID of the IPv4 address of the server. (***NOTE: The server will NOT automatically be connected to the public network; to give it access to the internet, please add server to the public network.)
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.IPv4
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// Reference to a IPv4 in gridscale to populate ipv4.
	// +kubebuilder:validation:Optional
	IPv4Ref *v1.Reference `json:"ipv4Ref,omitempty" tf:"-"`

	// Selector for a IPv4 in gridscale to populate ipv4.
	// +kubebuilder:validation:Optional
	IPv4Selector *v1.Selector `json:"ipv4Selector,omitempty" tf:"-"`

	// The UUID of the IPv6 address of the server. (***NOTE: The server will NOT automatically be connected to the public network; to give it access to the internet, please add server to the public network.)
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.IPv6
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Reference to a IPv6 in gridscale to populate ipv6.
	// +kubebuilder:validation:Optional
	IPv6Ref *v1.Reference `json:"ipv6Ref,omitempty" tf:"-"`

	// Selector for a IPv6 in gridscale to populate ipv6.
	// +kubebuilder:validation:Optional
	IPv6Selector *v1.Selector `json:"ipv6Selector,omitempty" tf:"-"`

	// The UUID of an ISO image in gridscale. The server will automatically boot from the ISO if one was added. The UUIDs of ISO images can be found in the expert panel.
	Isoimage *string `json:"isoimage,omitempty" tf:"isoimage,omitempty"`

	// List of labels in the format [ "label1", "label2" ].
	// List of labels.
	// +listType=set
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The amount of server memory in GB.
	// The amount of server memory in GB.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Connects a network to the server. The network ordering of the server corresponds to the order of the networks in the server resource block.
	Network []ServerNetworkInitParameters `json:"network,omitempty" tf:"network,omitempty"`

	// The power state of the server. Set this to true to will boot the server, false will shut it down.
	// The number of server cores.
	Power *bool `json:"power,omitempty" tf:"power,omitempty"`

	// Connects a storage to the server. **NOTE: The first storage is always the boot device.
	// A list of storages attached to the server. The first storage in the list is always set as the boot storage of the server.
	Storage []StorageInitParameters `json:"storage,omitempty" tf:"storage,omitempty"`

	// For system configuration on first boot. May contain cloud-config data or shell scripting, encoded as base64 string. Supported tools are cloud-init, Cloudbase-init, and Ignition.
	// For system configuration on first boot. May contain cloud-config data or shell scripting, encoded as base64 string. Supported tools are cloud-init, Cloudbase-init, and Ignition.
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`
}

type ServerNetworkInitParameters struct {

	// Make this network the boot device. This can only be set for one network.
	Bootdevice *bool `json:"bootdevice,omitempty" tf:"bootdevice,omitempty"`

	// The UUID of firewall template.
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.Firewall
	FirewallTemplateUUID *string `json:"firewallTemplateUuid,omitempty" tf:"firewall_template_uuid,omitempty"`

	// Reference to a Firewall in gridscale to populate firewallTemplateUuid.
	// +kubebuilder:validation:Optional
	FirewallTemplateUUIDRef *v1.Reference `json:"firewallTemplateUuidRef,omitempty" tf:"-"`

	// Selector for a Firewall in gridscale to populate firewallTemplateUuid.
	// +kubebuilder:validation:Optional
	FirewallTemplateUUIDSelector *v1.Selector `json:"firewallTemplateUuidSelector,omitempty" tf:"-"`

	// Manually assign DHCP IP to the server (if applicable).
	// Manually assign DHCP IP to the server.
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// The object UUID or id of the network.
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.Network
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`

	// Reference to a Network in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDRef *v1.Reference `json:"objectUuidRef,omitempty" tf:"-"`

	// Selector for a Network in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDSelector *v1.Selector `json:"objectUuidSelector,omitempty" tf:"-"`

	// DEPRECATED  Defines the ordering of the network interfaces. Lower numbers have lower PCI-IDs.
	Ordering *float64 `json:"ordering,omitempty" tf:"ordering,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv4 addresses.
	RulesV4In []NetworkRulesV4InInitParameters `json:"rulesV4In,omitempty" tf:"rules_v4_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv4 addresses.
	RulesV4Out []NetworkRulesV4OutInitParameters `json:"rulesV4Out,omitempty" tf:"rules_v4_out,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv6 addresses.
	RulesV6In []NetworkRulesV6InInitParameters `json:"rulesV6In,omitempty" tf:"rules_v6_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv6 addresses.
	RulesV6Out []NetworkRulesV6OutInitParameters `json:"rulesV6Out,omitempty" tf:"rules_v6_out,omitempty"`
}

type ServerNetworkObservation struct {

	// DHCP IP which is automatically assigned to the server (if applicable).
	// DHCP IP which is automatically assigned to the server.
	AutoAssignedIP *string `json:"autoAssignedIp,omitempty" tf:"auto_assigned_ip,omitempty"`

	// Make this network the boot device. This can only be set for one network.
	Bootdevice *bool `json:"bootdevice,omitempty" tf:"bootdevice,omitempty"`

	// Defines the date and time the object was initially created.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// The UUID of firewall template.
	FirewallTemplateUUID *string `json:"firewallTemplateUuid,omitempty" tf:"firewall_template_uuid,omitempty"`

	// Manually assign DHCP IP to the server (if applicable).
	// Manually assign DHCP IP to the server.
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// network_mac defines the MAC address of the network interface.
	Mac *string `json:"mac,omitempty" tf:"mac,omitempty"`

	// One of network, network_high, network_insane.
	NetworkType *string `json:"networkType,omitempty" tf:"network_type,omitempty"`

	// Name of the storage.
	ObjectName *string `json:"objectName,omitempty" tf:"object_name,omitempty"`

	// The object UUID or id of the network.
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`

	// DEPRECATED  Defines the ordering of the network interfaces. Lower numbers have lower PCI-IDs.
	Ordering *float64 `json:"ordering,omitempty" tf:"ordering,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv4 addresses.
	RulesV4In []NetworkRulesV4InObservation `json:"rulesV4In,omitempty" tf:"rules_v4_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv4 addresses.
	RulesV4Out []NetworkRulesV4OutObservation `json:"rulesV4Out,omitempty" tf:"rules_v4_out,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv6 addresses.
	RulesV6In []NetworkRulesV6InObservation `json:"rulesV6In,omitempty" tf:"rules_v6_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv6 addresses.
	RulesV6Out []NetworkRulesV6OutObservation `json:"rulesV6Out,omitempty" tf:"rules_v6_out,omitempty"`
}

type ServerNetworkParameters struct {

	// Make this network the boot device. This can only be set for one network.
	// +kubebuilder:validation:Optional
	Bootdevice *bool `json:"bootdevice,omitempty" tf:"bootdevice,omitempty"`

	// The UUID of firewall template.
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.Firewall
	// +kubebuilder:validation:Optional
	FirewallTemplateUUID *string `json:"firewallTemplateUuid,omitempty" tf:"firewall_template_uuid,omitempty"`

	// Reference to a Firewall in gridscale to populate firewallTemplateUuid.
	// +kubebuilder:validation:Optional
	FirewallTemplateUUIDRef *v1.Reference `json:"firewallTemplateUuidRef,omitempty" tf:"-"`

	// Selector for a Firewall in gridscale to populate firewallTemplateUuid.
	// +kubebuilder:validation:Optional
	FirewallTemplateUUIDSelector *v1.Selector `json:"firewallTemplateUuidSelector,omitempty" tf:"-"`

	// Manually assign DHCP IP to the server (if applicable).
	// Manually assign DHCP IP to the server.
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// The object UUID or id of the network.
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.Network
	// +kubebuilder:validation:Optional
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`

	// Reference to a Network in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDRef *v1.Reference `json:"objectUuidRef,omitempty" tf:"-"`

	// Selector for a Network in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDSelector *v1.Selector `json:"objectUuidSelector,omitempty" tf:"-"`

	// DEPRECATED  Defines the ordering of the network interfaces. Lower numbers have lower PCI-IDs.
	// +kubebuilder:validation:Optional
	Ordering *float64 `json:"ordering,omitempty" tf:"ordering,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv4 addresses.
	// +kubebuilder:validation:Optional
	RulesV4In []NetworkRulesV4InParameters `json:"rulesV4In,omitempty" tf:"rules_v4_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv4 addresses.
	// +kubebuilder:validation:Optional
	RulesV4Out []NetworkRulesV4OutParameters `json:"rulesV4Out,omitempty" tf:"rules_v4_out,omitempty"`

	// Firewall template rules for inbound traffic - covers ipv6 addresses.
	// +kubebuilder:validation:Optional
	RulesV6In []NetworkRulesV6InParameters `json:"rulesV6In,omitempty" tf:"rules_v6_in,omitempty"`

	// Firewall template rules for outbound traffic - covers ipv6 addresses.
	// +kubebuilder:validation:Optional
	RulesV6Out []NetworkRulesV6OutParameters `json:"rulesV6Out,omitempty" tf:"rules_v6_out,omitempty"`
}

type ServerObservation struct {

	// If the server should be auto-started in case of a failure (default=true).
	// If the server should be auto-started in case of a failure (default=true).
	AutoRecovery *bool `json:"autoRecovery,omitempty" tf:"auto_recovery,omitempty"`

	// Defines which Availability-Zone the Server is placed.
	// Defines which Availability-Zone the Server is placed.
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// Defines the date and time of the last object change.
	ChangeTime *string `json:"changeTime,omitempty" tf:"change_time,omitempty"`

	// The token used by the panel to open the websocket VNC connection to the server console.
	// The token used by the panel to open the websocket VNC connection to the server console.
	ConsoleToken *string `json:"consoleToken,omitempty" tf:"console_token,omitempty"`

	// The number of server cores.
	// The number of server cores.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Defines the date and time the object was initially created.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// The price for the current period since the last bill.
	CurrentPrice *float64 `json:"currentPrice,omitempty" tf:"current_price,omitempty"`

	// The hardware profile of the Server. Options are default, legacy, nested, cisco_csr, sophos_utm, f5_bigip and q35 at the moment of writing. If it is not set, the backend will set it by default. Check the official docs.
	// Specifies the hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time.
	HardwareProfile *string `json:"hardwareProfile,omitempty" tf:"hardware_profile,omitempty"`

	// Specifies the custom hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time. Note: If hardware_profile_config is set, all fields of hardware_profile_config MUST be set.
	// Specifies the custom hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time.
	HardwareProfileConfig []HardwareProfileConfigObservation `json:"hardwareProfileConfig,omitempty" tf:"hardware_profile_config,omitempty"`

	// UUID of the server.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The UUID of the IPv4 address of the server. (***NOTE: The server will NOT automatically be connected to the public network; to give it access to the internet, please add server to the public network.)
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// The UUID of the IPv6 address of the server. (***NOTE: The server will NOT automatically be connected to the public network; to give it access to the internet, please add server to the public network.)
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// The UUID of an ISO image in gridscale. The server will automatically boot from the ISO if one was added. The UUIDs of ISO images can be found in the expert panel.
	Isoimage *string `json:"isoimage,omitempty" tf:"isoimage,omitempty"`

	// List of labels in the format [ "label1", "label2" ].
	// List of labels.
	// +listType=set
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Legacy-Hardware emulation instead of virtio hardware. If enabled, hot-plugging cores, memory, storage, network, etc. will not work, but the server will most likely run every x86 compatible operating system. This mode comes with a performance penalty, as emulated hardware does not benefit from the virtio driver infrastructure.
	// Legacy-Hardware emulation instead of virtio hardware. If enabled, hotplugging cores, memory, storage, network, etc. will not work, but the server will most likely run every x86 compatible operating system. This mode comes with a performance penalty, as emulated hardware does not benefit from the virtio driver infrastructure.
	Legacy *bool `json:"legacy,omitempty" tf:"legacy,omitempty"`

	// The location this server is placed. The location of a resource is determined by it's project.
	// The location this object is placed.
	LocationUUID *string `json:"locationUuid,omitempty" tf:"location_uuid,omitempty"`

	// The amount of server memory in GB.
	// The amount of server memory in GB.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Connects a network to the server. The network ordering of the server corresponds to the order of the networks in the server resource block.
	Network []ServerNetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// The power state of the server. Set this to true to will boot the server, false will shut it down.
	// The number of server cores.
	Power *bool `json:"power,omitempty" tf:"power,omitempty"`

	// Status indicates the status of the object.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Connects a storage to the server. **NOTE: The first storage is always the boot device.
	// A list of storages attached to the server. The first storage in the list is always set as the boot storage of the server.
	Storage []StorageObservation `json:"storage,omitempty" tf:"storage,omitempty"`

	// Total minutes of cores used.
	UsageInMinutesCores *float64 `json:"usageInMinutesCores,omitempty" tf:"usage_in_minutes_cores,omitempty"`

	// Total minutes of memory used.
	UsageInMinutesMemory *float64 `json:"usageInMinutesMemory,omitempty" tf:"usage_in_minutes_memory,omitempty"`

	// For system configuration on first boot. May contain cloud-config data or shell scripting, encoded as base64 string. Supported tools are cloud-init, Cloudbase-init, and Ignition.
	// For system configuration on first boot. May contain cloud-config data or shell scripting, encoded as base64 string. Supported tools are cloud-init, Cloudbase-init, and Ignition.
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`
}

type ServerParameters struct {

	// If the server should be auto-started in case of a failure (default=true).
	// If the server should be auto-started in case of a failure (default=true).
	// +kubebuilder:validation:Optional
	AutoRecovery *bool `json:"autoRecovery,omitempty" tf:"auto_recovery,omitempty"`

	// Defines which Availability-Zone the Server is placed.
	// Defines which Availability-Zone the Server is placed.
	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// The number of server cores.
	// The number of server cores.
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// The hardware profile of the Server. Options are default, legacy, nested, cisco_csr, sophos_utm, f5_bigip and q35 at the moment of writing. If it is not set, the backend will set it by default. Check the official docs.
	// Specifies the hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time.
	// +kubebuilder:validation:Optional
	HardwareProfile *string `json:"hardwareProfile,omitempty" tf:"hardware_profile,omitempty"`

	// Specifies the custom hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time. Note: If hardware_profile_config is set, all fields of hardware_profile_config MUST be set.
	// Specifies the custom hardware settings for the virtual machine. Note: hardware_profile and hardware_profile_config parameters can't be used at the same time.
	// +kubebuilder:validation:Optional
	HardwareProfileConfig []HardwareProfileConfigParameters `json:"hardwareProfileConfig,omitempty" tf:"hardware_profile_config,omitempty"`

	// The UUID of the IPv4 address of the server. (***NOTE: The server will NOT automatically be connected to the public network; to give it access to the internet, please add server to the public network.)
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.IPv4
	// +kubebuilder:validation:Optional
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// Reference to a IPv4 in gridscale to populate ipv4.
	// +kubebuilder:validation:Optional
	IPv4Ref *v1.Reference `json:"ipv4Ref,omitempty" tf:"-"`

	// Selector for a IPv4 in gridscale to populate ipv4.
	// +kubebuilder:validation:Optional
	IPv4Selector *v1.Selector `json:"ipv4Selector,omitempty" tf:"-"`

	// The UUID of the IPv6 address of the server. (***NOTE: The server will NOT automatically be connected to the public network; to give it access to the internet, please add server to the public network.)
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.IPv6
	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Reference to a IPv6 in gridscale to populate ipv6.
	// +kubebuilder:validation:Optional
	IPv6Ref *v1.Reference `json:"ipv6Ref,omitempty" tf:"-"`

	// Selector for a IPv6 in gridscale to populate ipv6.
	// +kubebuilder:validation:Optional
	IPv6Selector *v1.Selector `json:"ipv6Selector,omitempty" tf:"-"`

	// The UUID of an ISO image in gridscale. The server will automatically boot from the ISO if one was added. The UUIDs of ISO images can be found in the expert panel.
	// +kubebuilder:validation:Optional
	Isoimage *string `json:"isoimage,omitempty" tf:"isoimage,omitempty"`

	// List of labels in the format [ "label1", "label2" ].
	// List of labels.
	// +kubebuilder:validation:Optional
	// +listType=set
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The amount of server memory in GB.
	// The amount of server memory in GB.
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters.
	// The human-readable name of the object. It supports the full UTF-8 character set, with a maximum of 64 characters
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Connects a network to the server. The network ordering of the server corresponds to the order of the networks in the server resource block.
	// +kubebuilder:validation:Optional
	Network []ServerNetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// The power state of the server. Set this to true to will boot the server, false will shut it down.
	// The number of server cores.
	// +kubebuilder:validation:Optional
	Power *bool `json:"power,omitempty" tf:"power,omitempty"`

	// Connects a storage to the server. **NOTE: The first storage is always the boot device.
	// A list of storages attached to the server. The first storage in the list is always set as the boot storage of the server.
	// +kubebuilder:validation:Optional
	Storage []StorageParameters `json:"storage,omitempty" tf:"storage,omitempty"`

	// For system configuration on first boot. May contain cloud-config data or shell scripting, encoded as base64 string. Supported tools are cloud-init, Cloudbase-init, and Ignition.
	// For system configuration on first boot. May contain cloud-config data or shell scripting, encoded as base64 string. Supported tools are cloud-init, Cloudbase-init, and Ignition.
	// +kubebuilder:validation:Optional
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`
}

type StorageInitParameters struct {

	// The object UUID or id of the storage.
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.Storage
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`

	// Reference to a Storage in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDRef *v1.Reference `json:"objectUuidRef,omitempty" tf:"-"`

	// Selector for a Storage in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDSelector *v1.Selector `json:"objectUuidSelector,omitempty" tf:"-"`
}

type StorageObservation struct {

	// Make this network the boot device. This can only be set for one network.
	Bootdevice *bool `json:"bootdevice,omitempty" tf:"bootdevice,omitempty"`

	// The SCSI bus id. The SCSI defines transmission routes like Serial Attached SCSI (SAS), Fibre Channel and iSCSI. Each SCSI device is addressed via a specific number. Each SCSI bus can have multiple SCSI devices connected to it.
	Bus *float64 `json:"bus,omitempty" tf:"bus,omitempty"`

	// Capacity of the storage (GB).
	Capacity *float64 `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// Defines the SCSI controller id. The SCSI defines transmission routes such as Serial Attached SCSI (SAS), Fibre Channel and iSCSI.
	Controller *float64 `json:"controller,omitempty" tf:"controller,omitempty"`

	// Defines the date and time the object was initially created.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// Indicates the UUID of the last used template on this storage (inherited from snapshots).
	LastUsedTemplate *string `json:"lastUsedTemplate,omitempty" tf:"last_used_template,omitempty"`

	// If a template has been used that requires a license key (e.g. Windows Servers) this shows the product_no of the license (see the /prices endpoint for more details).
	LicenseProductNo *float64 `json:"licenseProductNo,omitempty" tf:"license_product_no,omitempty"`

	// Is the common SCSI abbreviation of the Logical Unit Number. A lun is a unique identifier for a single disk or a composite of disks.
	Lun *float64 `json:"lun,omitempty" tf:"lun,omitempty"`

	// Name of the storage.
	ObjectName *string `json:"objectName,omitempty" tf:"object_name,omitempty"`

	// The object UUID or id of the storage.
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`

	// Indicates the speed of the storage. This may be (storage, storage_high or storage_insane).
	StorageType *string `json:"storageType,omitempty" tf:"storage_type,omitempty"`

	// Defines the SCSI target ID. The target ID is a device (e.g. disk).
	Target *float64 `json:"target,omitempty" tf:"target,omitempty"`
}

type StorageParameters struct {

	// The object UUID or id of the storage.
	// +crossplane:generate:reference:type=github.com/dNationCloud/provider-gridscale/apis/gridscale/v1alpha1.Storage
	// +kubebuilder:validation:Optional
	ObjectUUID *string `json:"objectUuid,omitempty" tf:"object_uuid,omitempty"`

	// Reference to a Storage in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDRef *v1.Reference `json:"objectUuidRef,omitempty" tf:"-"`

	// Selector for a Storage in gridscale to populate objectUuid.
	// +kubebuilder:validation:Optional
	ObjectUUIDSelector *v1.Selector `json:"objectUuidSelector,omitempty" tf:"-"`
}

// ServerSpec defines the desired state of Server
type ServerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServerParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ServerInitParameters `json:"initProvider,omitempty"`
}

// ServerStatus defines the observed state of Server.
type ServerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Server is the Schema for the Servers API. Manages a server in gridscale.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gridscale}
type Server struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.cores) || (has(self.initProvider) && has(self.initProvider.cores))",message="spec.forProvider.cores is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.memory) || (has(self.initProvider) && has(self.initProvider.memory))",message="spec.forProvider.memory is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ServerSpec   `json:"spec"`
	Status ServerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServerList contains a list of Servers
type ServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Server `json:"items"`
}

// Repository type metadata.
var (
	Server_Kind             = "Server"
	Server_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Server_Kind}.String()
	Server_KindAPIVersion   = Server_Kind + "." + CRDGroupVersion.String()
	Server_GroupVersionKind = CRDGroupVersion.WithKind(Server_Kind)
)

func init() {
	SchemeBuilder.Register(&Server{}, &ServerList{})
}
